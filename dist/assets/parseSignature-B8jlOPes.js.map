{"version":3,"file":"parseSignature-B8jlOPes.js","sources":["../../node_modules/viem/_esm/utils/abi/encodePacked.js","../../node_modules/viem/_esm/utils/nonceManager.js","../../node_modules/viem/_esm/constants/bytes.js","../../node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js","../../node_modules/viem/_esm/actions/wallet/sendCalls.js","../../node_modules/viem/_esm/actions/wallet/getCallsStatus.js","../../node_modules/viem/_esm/errors/calls.js","../../node_modules/viem/_esm/actions/wallet/waitForCallsStatus.js","../../node_modules/viem/_esm/utils/signature/parseSignature.js"],"sourcesContent":["import { AbiEncodingLengthMismatchError, BytesSizeMismatchError, UnsupportedPackedAbiType, } from '../../errors/abi.js';\nimport { InvalidAddressError, } from '../../errors/address.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { concatHex } from '../data/concat.js';\nimport { pad } from '../data/pad.js';\nimport { boolToHex, numberToHex, stringToHex, } from '../encoding/toHex.js';\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex.js';\nexport function encodePacked(types, values) {\n    if (types.length !== values.length)\n        throw new AbiEncodingLengthMismatchError({\n            expectedLength: types.length,\n            givenLength: values.length,\n        });\n    const data = [];\n    for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const value = values[i];\n        data.push(encode(type, value));\n    }\n    return concatHex(data);\n}\nfunction encode(type, value, isArray = false) {\n    if (type === 'address') {\n        const address = value;\n        if (!isAddress(address))\n            throw new InvalidAddressError({ address });\n        return pad(address.toLowerCase(), {\n            size: isArray ? 32 : null,\n        });\n    }\n    if (type === 'string')\n        return stringToHex(value);\n    if (type === 'bytes')\n        return value;\n    if (type === 'bool')\n        return pad(boolToHex(value), { size: isArray ? 32 : 1 });\n    const intMatch = type.match(integerRegex);\n    if (intMatch) {\n        const [_type, baseType, bits = '256'] = intMatch;\n        const size = Number.parseInt(bits, 10) / 8;\n        return numberToHex(value, {\n            size: isArray ? 32 : size,\n            signed: baseType === 'int',\n        });\n    }\n    const bytesMatch = type.match(bytesRegex);\n    if (bytesMatch) {\n        const [_type, size] = bytesMatch;\n        if (Number.parseInt(size, 10) !== (value.length - 2) / 2)\n            throw new BytesSizeMismatchError({\n                expectedSize: Number.parseInt(size, 10),\n                givenSize: (value.length - 2) / 2,\n            });\n        return pad(value, { dir: 'right', size: isArray ? 32 : null });\n    }\n    const arrayMatch = type.match(arrayRegex);\n    if (arrayMatch && Array.isArray(value)) {\n        const [_type, childType] = arrayMatch;\n        const data = [];\n        for (let i = 0; i < value.length; i++) {\n            data.push(encode(childType, value[i], true));\n        }\n        if (data.length === 0)\n            return '0x';\n        return concatHex(data);\n    }\n    throw new UnsupportedPackedAbiType(type);\n}\n//# sourceMappingURL=encodePacked.js.map","import { getTransactionCount } from '../actions/public/getTransactionCount.js';\nimport { LruMap } from './lru.js';\n/**\n * Creates a nonce manager for auto-incrementing transaction nonces.\n *\n * - Docs: https://viem.sh/docs/accounts/createNonceManager\n *\n * @example\n * ```ts\n * const nonceManager = createNonceManager({\n *   source: jsonRpc(),\n * })\n * ```\n */\nexport function createNonceManager(parameters) {\n    const { source } = parameters;\n    const deltaMap = new Map();\n    const nonceMap = new LruMap(8192);\n    const promiseMap = new Map();\n    const getKey = ({ address, chainId }) => `${address}.${chainId}`;\n    return {\n        async consume({ address, chainId, client }) {\n            const key = getKey({ address, chainId });\n            const promise = this.get({ address, chainId, client });\n            this.increment({ address, chainId });\n            const nonce = await promise;\n            await source.set({ address, chainId }, nonce);\n            nonceMap.set(key, nonce);\n            return nonce;\n        },\n        async increment({ address, chainId }) {\n            const key = getKey({ address, chainId });\n            const delta = deltaMap.get(key) ?? 0;\n            deltaMap.set(key, delta + 1);\n        },\n        async get({ address, chainId, client }) {\n            const key = getKey({ address, chainId });\n            let promise = promiseMap.get(key);\n            if (!promise) {\n                promise = (async () => {\n                    try {\n                        const nonce = await source.get({ address, chainId, client });\n                        const previousNonce = nonceMap.get(key) ?? 0;\n                        if (previousNonce > 0 && nonce <= previousNonce)\n                            return previousNonce + 1;\n                        nonceMap.delete(key);\n                        return nonce;\n                    }\n                    finally {\n                        this.reset({ address, chainId });\n                    }\n                })();\n                promiseMap.set(key, promise);\n            }\n            const delta = deltaMap.get(key) ?? 0;\n            return delta + (await promise);\n        },\n        reset({ address, chainId }) {\n            const key = getKey({ address, chainId });\n            deltaMap.delete(key);\n            promiseMap.delete(key);\n        },\n    };\n}\n/** JSON-RPC source for a nonce manager. */\nexport function jsonRpc() {\n    return {\n        async get(parameters) {\n            const { address, client } = parameters;\n            return getTransactionCount(client, {\n                address,\n                blockTag: 'pending',\n            });\n        },\n        set() { },\n    };\n}\n////////////////////////////////////////////////////////////////////////////////////////////\n// Default\n/** Default Nonce Manager with a JSON-RPC source. */\nexport const nonceManager = /*#__PURE__*/ createNonceManager({\n    source: jsonRpc(),\n});\n//# sourceMappingURL=nonceManager.js.map","export const erc6492MagicBytes = '0x6492649264926492649264926492649264926492649264926492649264926492';\nexport const zeroHash = '0x0000000000000000000000000000000000000000000000000000000000000000';\n//# sourceMappingURL=bytes.js.map","import { erc6492MagicBytes } from '../../constants/bytes.js';\nimport { encodeAbiParameters } from '../abi/encodeAbiParameters.js';\nimport { concatHex } from '../data/concat.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\n/**\n * @description Serializes a ERC-6492 flavoured signature into hex format.\n *\n * @param signature ERC-6492 signature in object format.\n * @returns ERC-6492 signature in hex format.\n *\n * @example\n * serializeSignature({ address: '0x...', data: '0x...', signature: '0x...' })\n * // '0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492'\n */\nexport function serializeErc6492Signature(parameters) {\n    const { address, data, signature, to = 'hex' } = parameters;\n    const signature_ = concatHex([\n        encodeAbiParameters([{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }], [address, data, signature]),\n        erc6492MagicBytes,\n    ]);\n    if (to === 'hex')\n        return signature_;\n    return hexToBytes(signature_);\n}\n//# sourceMappingURL=serializeErc6492Signature.js.map","import { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { BaseError } from '../../errors/base.js';\nimport { AtomicityNotSupportedError, UnsupportedNonOptionalCapabilityError, } from '../../errors/rpc.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { concat } from '../../utils/data/concat.js';\nimport { hexToBigInt } from '../../utils/encoding/fromHex.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { getTransactionError } from '../../utils/errors/getTransactionError.js';\nimport { sendTransaction } from './sendTransaction.js';\nexport const fallbackMagicIdentifier = '0x5792579257925792579257925792579257925792579257925792579257925792';\nexport const fallbackTransactionErrorMagicIdentifier = numberToHex(0, {\n    size: 32,\n});\n/**\n * Requests the connected wallet to send a batch of calls.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendCalls\n * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Transaction identifier. {@link SendCallsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendCalls } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const id = await sendCalls(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: 69420n,\n *     },\n *   ],\n * })\n */\nexport async function sendCalls(client, parameters) {\n    const { account: account_ = client.account, capabilities, chain = client.chain, experimental_fallback, experimental_fallbackDelay = 32, forceAtomic = false, id, version = '2.0.0', } = parameters;\n    const account = account_ ? parseAccount(account_) : null;\n    const calls = parameters.calls.map((call_) => {\n        const call = call_;\n        const data = call.abi\n            ? encodeFunctionData({\n                abi: call.abi,\n                functionName: call.functionName,\n                args: call.args,\n            })\n            : call.data;\n        return {\n            data: call.dataSuffix && data ? concat([data, call.dataSuffix]) : data,\n            to: call.to,\n            value: call.value ? numberToHex(call.value) : undefined,\n        };\n    });\n    try {\n        const response = await client.request({\n            method: 'wallet_sendCalls',\n            params: [\n                {\n                    atomicRequired: forceAtomic,\n                    calls,\n                    capabilities,\n                    chainId: numberToHex(chain.id),\n                    from: account?.address,\n                    id,\n                    version,\n                },\n            ],\n        }, { retryCount: 0 });\n        if (typeof response === 'string')\n            return { id: response };\n        return response;\n    }\n    catch (err) {\n        const error = err;\n        // If the transport does not support EIP-5792, fall back to\n        // `eth_sendTransaction`.\n        if (experimental_fallback &&\n            (error.name === 'MethodNotFoundRpcError' ||\n                error.name === 'MethodNotSupportedRpcError' ||\n                error.name === 'UnknownRpcError' ||\n                error.details\n                    .toLowerCase()\n                    .includes('does not exist / is not available') ||\n                error.details.toLowerCase().includes('missing or invalid. request()') ||\n                error.details\n                    .toLowerCase()\n                    .includes('did not match any variant of untagged enum') ||\n                error.details\n                    .toLowerCase()\n                    .includes('account upgraded to unsupported contract') ||\n                error.details.toLowerCase().includes('eip-7702 not supported') ||\n                error.details.toLowerCase().includes('unsupported wc_ method') ||\n                // magic.link\n                error.details\n                    .toLowerCase()\n                    .includes('feature toggled misconfigured') ||\n                // Trust Wallet\n                error.details\n                    .toLowerCase()\n                    .includes('jsonrpcengine: response has no error or result for request'))) {\n            if (capabilities) {\n                const hasNonOptionalCapability = Object.values(capabilities).some((capability) => !capability.optional);\n                if (hasNonOptionalCapability) {\n                    const message = 'non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.';\n                    throw new UnsupportedNonOptionalCapabilityError(new BaseError(message, {\n                        details: message,\n                    }));\n                }\n            }\n            if (forceAtomic && calls.length > 1) {\n                const message = '`forceAtomic` is not supported on fallback to `eth_sendTransaction`.';\n                throw new AtomicityNotSupportedError(new BaseError(message, {\n                    details: message,\n                }));\n            }\n            const promises = [];\n            for (const call of calls) {\n                const promise = sendTransaction(client, {\n                    account,\n                    chain,\n                    data: call.data,\n                    to: call.to,\n                    value: call.value ? hexToBigInt(call.value) : undefined,\n                });\n                promises.push(promise);\n                // Note: some browser wallets require a small delay between transactions\n                // to prevent duplicate JSON-RPC requests.\n                if (experimental_fallbackDelay > 0)\n                    await new Promise((resolve) => setTimeout(resolve, experimental_fallbackDelay));\n            }\n            const results = await Promise.allSettled(promises);\n            if (results.every((r) => r.status === 'rejected'))\n                throw results[0].reason;\n            const hashes = results.map((result) => {\n                if (result.status === 'fulfilled')\n                    return result.value;\n                return fallbackTransactionErrorMagicIdentifier;\n            });\n            return {\n                id: concat([\n                    ...hashes,\n                    numberToHex(chain.id, { size: 32 }),\n                    fallbackMagicIdentifier,\n                ]),\n            };\n        }\n        throw getTransactionError(err, {\n            ...parameters,\n            account,\n            chain: parameters.chain,\n        });\n    }\n}\n//# sourceMappingURL=sendCalls.js.map","import { sliceHex } from '../../utils/data/slice.js';\nimport { trim } from '../../utils/data/trim.js';\nimport { hexToBigInt, hexToNumber } from '../../utils/encoding/fromHex.js';\nimport { receiptStatuses } from '../../utils/formatters/transactionReceipt.js';\nimport { fallbackMagicIdentifier, fallbackTransactionErrorMagicIdentifier, } from './sendCalls.js';\n/**\n * Returns the status of a call batch that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Status of the calls. {@link GetCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const { receipts, status } = await getCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function getCallsStatus(client, parameters) {\n    async function getStatus(id) {\n        const isTransactions = id.endsWith(fallbackMagicIdentifier.slice(2));\n        if (isTransactions) {\n            const chainId = trim(sliceHex(id, -64, -32));\n            const hashes = sliceHex(id, 0, -64)\n                .slice(2)\n                .match(/.{1,64}/g);\n            const receipts = await Promise.all(hashes.map((hash) => fallbackTransactionErrorMagicIdentifier.slice(2) !== hash\n                ? client.request({\n                    method: 'eth_getTransactionReceipt',\n                    params: [`0x${hash}`],\n                }, { dedupe: true })\n                : undefined));\n            const status = (() => {\n                if (receipts.some((r) => r === null))\n                    return 100; // pending\n                if (receipts.every((r) => r?.status === '0x1'))\n                    return 200; // success\n                if (receipts.every((r) => r?.status === '0x0'))\n                    return 500; // complete failure\n                return 600; // partial failure\n            })();\n            return {\n                atomic: false,\n                chainId: hexToNumber(chainId),\n                receipts: receipts.filter(Boolean),\n                status,\n                version: '2.0.0',\n            };\n        }\n        return client.request({\n            method: 'wallet_getCallsStatus',\n            params: [id],\n        });\n    }\n    const { atomic = false, chainId, receipts, version = '2.0.0', ...response } = await getStatus(parameters.id);\n    const [status, statusCode] = (() => {\n        const statusCode = response.status;\n        if (statusCode >= 100 && statusCode < 200)\n            return ['pending', statusCode];\n        if (statusCode >= 200 && statusCode < 300)\n            return ['success', statusCode];\n        if (statusCode >= 300 && statusCode < 700)\n            return ['failure', statusCode];\n        // @ts-expect-error: for backwards compatibility\n        if (statusCode === 'CONFIRMED')\n            return ['success', 200];\n        // @ts-expect-error: for backwards compatibility\n        if (statusCode === 'PENDING')\n            return ['pending', 100];\n        return [undefined, statusCode];\n    })();\n    return {\n        ...response,\n        atomic,\n        // @ts-expect-error: for backwards compatibility\n        chainId: chainId ? hexToNumber(chainId) : undefined,\n        receipts: receipts?.map((receipt) => ({\n            ...receipt,\n            blockNumber: hexToBigInt(receipt.blockNumber),\n            gasUsed: hexToBigInt(receipt.gasUsed),\n            status: receiptStatuses[receipt.status],\n        })) ?? [],\n        statusCode,\n        status,\n        version,\n    };\n}\n//# sourceMappingURL=getCallsStatus.js.map","import { BaseError } from './base.js';\nexport class BundleFailedError extends BaseError {\n    constructor(result) {\n        super(`Call bundle failed with status: ${result.statusCode}`, {\n            name: 'BundleFailedError',\n        });\n        Object.defineProperty(this, \"result\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.result = result;\n    }\n}\n//# sourceMappingURL=calls.js.map","import { BaseError } from '../../errors/base.js';\nimport { BundleFailedError } from '../../errors/calls.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { withResolvers } from '../../utils/promise/withResolvers.js';\nimport { withRetry, } from '../../utils/promise/withRetry.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getCallsStatus, } from './getCallsStatus.js';\n/**\n * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForCallsStatusParameters}\n * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function waitForCallsStatus(client, parameters) {\n    const { id, pollingInterval = client.pollingInterval, status = ({ statusCode }) => statusCode === 200 || statusCode >= 300, retryCount = 4, retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 60_000, throwOnFailure = false, } = parameters;\n    const observerId = stringify(['waitForCallsStatus', client.uid, id]);\n    const { promise, resolve, reject } = withResolvers();\n    let timer;\n    const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n        const unpoll = poll(async () => {\n            const done = (fn) => {\n                clearTimeout(timer);\n                unpoll();\n                fn();\n                unobserve();\n            };\n            try {\n                const result = await withRetry(async () => {\n                    const result = await getAction(client, getCallsStatus, 'getCallsStatus')({ id });\n                    if (throwOnFailure && result.status === 'failure')\n                        throw new BundleFailedError(result);\n                    return result;\n                }, {\n                    retryCount,\n                    delay: retryDelay,\n                });\n                if (!status(result))\n                    return;\n                done(() => emit.resolve(result));\n            }\n            catch (error) {\n                done(() => emit.reject(error));\n            }\n        }, {\n            interval: pollingInterval,\n            emitOnBegin: true,\n        });\n        return unpoll;\n    });\n    timer = timeout\n        ? setTimeout(() => {\n            unobserve();\n            clearTimeout(timer);\n            reject(new WaitForCallsStatusTimeoutError({ id }));\n        }, timeout)\n        : undefined;\n    return await promise;\n}\nexport class WaitForCallsStatusTimeoutError extends BaseError {\n    constructor({ id }) {\n        super(`Timed out while waiting for call bundle with id \"${id}\" to be confirmed.`, { name: 'WaitForCallsStatusTimeoutError' });\n    }\n}\n//# sourceMappingURL=waitForCallsStatus.js.map","import { secp256k1 } from '@noble/curves/secp256k1';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\n/**\n * @description Parses a hex formatted signature into a structured signature.\n *\n * @param signatureHex Signature in hex format.\n * @returns The structured signature.\n *\n * @example\n * parseSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // { r: '0x...', s: '0x...', v: 28n }\n */\nexport function parseSignature(signatureHex) {\n    const { r, s } = secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));\n    const yParityOrV = Number(`0x${signatureHex.slice(130)}`);\n    const [v, yParity] = (() => {\n        if (yParityOrV === 0 || yParityOrV === 1)\n            return [undefined, yParityOrV];\n        if (yParityOrV === 27)\n            return [BigInt(yParityOrV), 0];\n        if (yParityOrV === 28)\n            return [BigInt(yParityOrV), 1];\n        throw new Error('Invalid yParityOrV value');\n    })();\n    if (typeof v !== 'undefined')\n        return {\n            r: numberToHex(r, { size: 32 }),\n            s: numberToHex(s, { size: 32 }),\n            v,\n            yParity,\n        };\n    return {\n        r: numberToHex(r, { size: 32 }),\n        s: numberToHex(s, { size: 32 }),\n        yParity,\n    };\n}\n//# sourceMappingURL=parseSignature.js.map"],"names":["encodePacked","types","values","AbiEncodingLengthMismatchError","data","i","type","value","encode","concatHex","isArray","address","isAddress","InvalidAddressError","pad","stringToHex","boolToHex","intMatch","integerRegex","_type","baseType","bits","size","numberToHex","bytesMatch","bytesRegex","BytesSizeMismatchError","arrayMatch","arrayRegex","childType","UnsupportedPackedAbiType","createNonceManager","parameters","source","deltaMap","nonceMap","LruMap","promiseMap","getKey","chainId","client","key","promise","nonce","delta","previousNonce","erc6492MagicBytes","serializeErc6492Signature","signature","to","signature_","encodeAbiParameters","hexToBytes","fallbackMagicIdentifier","fallbackTransactionErrorMagicIdentifier","getCallsStatus","getStatus","id","trim","sliceHex","hashes","receipts","hash","status","r","hexToNumber","atomic","version","response","statusCode","receipt","hexToBigInt","receiptStatuses","BundleFailedError","BaseError","result","waitForCallsStatus","pollingInterval","retryCount","retryDelay","count","timeout","throwOnFailure","observerId","stringify","resolve","reject","withResolvers","timer","unobserve","observe","emit","unpoll","poll","done","fn","withRetry","getAction","error","WaitForCallsStatusTimeoutError","parseSignature","signatureHex","s","secp256k1","yParityOrV","v","yParity"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}